name: Deploy to Production Environment

on:
  push:
    branches:
      - development
  workflow_dispatch:
    inputs:
      source_tag:
        description: "Source image tag to re-tag and deploy (e.g., latest, v1.0.0)"
        required: true
        default: "latest"

env:
  REGISTRY: docker.io
  IMAGE_NAME: ${{ secrets.DOCKERHUB_USERNAME }}/academianovit

jobs:
  retag-and-deploy:
    name: Re-tag and Deploy to DEV
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Set deployment tag
        id: set_tag
        run: |
          # Default to 'development' tag unless specified
          if [ -n "${{ github.event.inputs.source_tag }}" ]; then
            SOURCE_TAG="${{ github.event.inputs.source_tag }}"
            echo "â„¹ï¸  Using specified tag: $SOURCE_TAG"
          else
            # Default to development tag
            SOURCE_TAG="development"
            echo "â„¹ï¸  Using default development tag"
          fi
          
          # For push events, we'll still use the SHA for the deploy tag
          if [ "${{ github.event_name }}" = "push" ]; then
            echo "â„¹ï¸  Push event detected, using SHA for deploy tag"
          fi
          
          # Generate a deploy tag with timestamp
          DEPLOY_TAG="deploy-$(date +%Y%m%d-%H%M%S)"
          
          # Set outputs
          echo "source_tag=${SOURCE_TAG}" >> $GITHUB_OUTPUT
          echo "deploy_tag=${DEPLOY_TAG}" >> $GITHUB_OUTPUT
          
          # Log information
          echo "ğŸ“ Source tag: ${SOURCE_TAG}"
          echo "ğŸ“ Deploy tag: ${DEPLOY_TAG}"

      - name: Re-tag and push Docker image
        run: |
          # Debug information
          echo "ğŸ” Debug Info:"
          echo "- DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}"
          echo "- IMAGE_NAME: ${{ env.IMAGE_NAME }}"
          echo "- SOURCE_TAG: ${{ steps.set_tag.outputs.source_tag }}"
          
          # Construct full image reference
          IMAGE_REF="${{ env.REGISTRY }}/${{ secrets.DOCKERHUB_USERNAME }}/academianovit:${{ steps.set_tag.outputs.source_tag }}"
          echo "ğŸ“¦ Full image reference: ${IMAGE_REF}"
          
          # Pull the source image
          echo "ğŸ” Pulling source image from Docker Hub..."
          if ! docker pull "${IMAGE_REF}"; then
            echo "âŒ Failed to pull image. Please check:"
            echo "1. DOCKERHUB_USERNAME and DOCKERHUB_TOKEN secrets are set in GitHub"
            echo "2. The image exists in your Docker Hub repository"
            echo "3. The tag is correct"
            exit 1
          fi

          # Create new tags
          echo "ğŸ·ï¸ Creating new tags..."
          docker tag ${{ env.IMAGE_NAME }}:${{ steps.set_tag.outputs.source_tag }} ${{ env.IMAGE_NAME }}:${{ steps.set_tag.outputs.deploy_tag }}
          docker tag ${{ env.IMAGE_NAME }}:${{ steps.set_tag.outputs.source_tag }} ${{ env.IMAGE_NAME }}:latest

          # Push all tags to Docker Hub
          echo "ğŸ“¤ Pushing images to Docker Hub..."
          docker push ${{ env.IMAGE_NAME }}:${{ steps.set_tag.outputs.deploy_tag }}
          docker push ${{ env.IMAGE_NAME }}:latest

          echo "âœ… Image re-tagging and pushing completed!"
          echo "   - Source: ${{ env.IMAGE_NAME }}:${{ steps.set_tag.outputs.source_tag }}"
          echo "   - New Tag: ${{ env.IMAGE_NAME }}:${{ steps.set_tag.outputs.deploy_tag }}"
          echo "   - Latest: ${{ env.IMAGE_NAME }}:latest"

      - name: Set up SSH key
        run: |
          echo "ğŸ” Setting up SSH key..."
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -p "${{ secrets.SSH_PORT }}" "${{ secrets.SSH_HOST }}" >> ~/.ssh/known_hosts
          
          echo "ğŸ” Testing SSH connection..."
          if ! ssh -o BatchMode=yes -p "${{ secrets.SSH_PORT }}" "${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}" exit; then
            echo "âŒ SSH connection failed to ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:${{ secrets.SSH_PORT }}"
            echo "Please verify:"
            echo "1. The SSH private key is correctly set in GitHub secrets"
            echo "2. The corresponding public key is in ~/.ssh/authorized_keys on the server"
            echo "3. The SSH user has the necessary permissions"
            exit 1
          fi
          
          echo "âœ… SSH connection verified"

      - name: Create remote directory
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          port: ${{ secrets.SSH_PORT }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            echo "ğŸ“‚ Creating remote directory if it doesn't exist..."
            mkdir -p ~/academianovit
            echo "âœ… Directory ready"

      - name: Copy docker-compose to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SSH_HOST }}
          port: ${{ secrets.SSH_PORT }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          source: "docker-compose.yml"
          target: "~/academianovit/"
          overwrite: true
          strip_components: 0
          debug: true

      - name: Deploy to production server via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          port: ${{ secrets.SSH_PORT }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            set -e

            echo "ğŸš€ Starting production deployment..."
            cd ~/academianovit

            # Install Docker Compose in user's home directory if not present
            if ! command -v docker-compose &> /dev/null; then
              echo "ğŸ“¦ Installing Docker Compose in user's home directory..."
              mkdir -p ~/bin
              curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o ~/bin/docker-compose
              chmod +x ~/bin/docker-compose
              export PATH="$HOME/bin:$PATH"
              echo "âœ… Docker Compose installed at ~/bin/docker-compose"
              
              # Verify Docker Compose installation
              if ! ~/bin/docker-compose --version &> /dev/null; then
                echo "âŒ Failed to install Docker Compose"
                exit 1
              fi
            fi
            
            # Ensure docker-compose is in PATH for all commands
            export PATH="$HOME/bin:$PATH"

            # Set environment variables
            export DOCKERHUB_USERNAME="${{ secrets.DOCKERHUB_USERNAME }}"
            export IMAGE_TAG="${{ steps.set_tag.outputs.deploy_tag }}"

            # Login to Docker Hub
            echo "${{ secrets.DOCKERHUB_TOKEN }}" | docker login --username "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin

            # Stop any processes using the required ports
            echo "ğŸ›‘ Checking for processes using required ports..."
            for port in 80 443 5432; do
              # Check for Docker containers first
              container_id=$(docker ps --format '{{.ID}}' --filter "publish=$port" || true)
              if [ -n "$container_id" ]; then
                echo "Stopping Docker container $container_id using port $port..."
                docker stop $container_id || true
                docker rm -f $container_id || true
              fi
              
              # Check for host processes
              if command -v lsof > /dev/null; then
                pid=$(sudo lsof -t -i ":$port" || true)
                if [ -n "$pid" ]; then
                  echo "Found host process $pid using port $port, stopping it..."
                  sudo kill -9 $pid || true
                fi
              elif command -v ss > /dev/null; then
                pid=$(sudo ss -tulpn | grep ":$port " | awk '{print $7}' | cut -d'"' -f2 | cut -d',' -f2 | uniq || true)
                if [ -n "$pid" ] && [ "$pid" != "-" ]; then
                  echo "Found host process $pid using port $port, stopping it..."
                  sudo kill -9 $pid || true
                fi
              fi
            done

            # Clean up any remaining containers from previous deployments
            echo "ğŸ§¹ Cleaning up previous deployment..."
            if [ -f docker-compose.yml ]; then
              docker-compose down --remove-orphans -v --timeout 30 || true
            fi

            # Clean up unused resources
            echo "ğŸ§¹ Cleaning up unused Docker resources..."
            docker system prune -af --volumes --filter "label!=keep" || true

            # Create a modified docker-compose file with updated ports
            echo "ğŸ”„ Creating modified docker-compose.yml with updated ports..."
            # Change PostgreSQL port from 5432 to 5433
            # Change web port from 80 to 8080
            sed -e 's/"5432:5432"/"5433:5432"/' \
                -e 's/"80:80"/"8080:80"/' \
                docker-compose.yml > docker-compose.deploy.yml
            
            # Update the connection string in the web service if needed
            # (keeping the internal container port as 5432)
            
            echo "âœ… Created docker-compose.deploy.yml with port 5433 for PostgreSQL"

            # Pull the newly tagged image
            echo "ğŸ“¥ Pulling new image from Docker Hub..."
            docker pull ${{ env.IMAGE_NAME }}:${{ steps.set_tag.outputs.deploy_tag }}

            # Start services using the modified compose file
            echo "ğŸš€ Starting services with docker-compose..."
            docker-compose -f docker-compose.deploy.yml up -d --remove-orphans

            # Verify deployment
            echo "â³ Waiting for services to start..."
            sleep 30

            echo "ğŸ“Š Service Status:"
            docker-compose -f docker-compose.deploy.yml ps

            # Health check on the new port
            echo "ğŸ” Running health checks..."
            if curl -f http://localhost:8080 > /dev/null 2>&1; then
              echo "âœ… Web service is responding on port 8080"
            else
              echo "âŒ Web service not responding on port 8080"
              echo "ğŸ“‹ Container logs:"
              docker-compose -f docker-compose.deploy.yml logs --tail=50
              exit 1
            fi

            echo "ğŸ³ Docker containers:"
            docker ps --format "table {{.ID}}\t{{.Names}}\t{{.Status}}\t{{.Ports}}"

            echo "âœ… Deployment completed successfully!"
            echo "ğŸ“ Deployed version: ${{ steps.set_tag.outputs.deploy_tag }}"
            echo "ğŸ”— Image: ${{ env.IMAGE_NAME }}:${{ steps.set_tag.outputs.deploy_tag }}"
