name: Deploy to DEV with Docker Swarm

on:
  push:
    branches: [development]
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Docker image tag to deploy'
        required: true
        default: 'development'

# Environment variables
defaults:
  run:
    shell: bash

env:
  IMAGE_NAME: academianovit
  DEFAULT_TAG: development
  SSH_OPTS: "-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=30"

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set image tag
        id: set_tag
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
          else
            echo "tag=${{ env.DEFAULT_TAG }}" >> $GITHUB_OUTPUT
          fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          install: true

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          tags: ${{ env.IMAGE_NAME }}:${{ steps.set_tag.outputs.tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Setup SSH connection
        run: |
          set -ex  # Enable debug mode and exit on error
          
          echo "üöÄ Setting up SSH connection..."
          echo "üîç Debug Info:"
          echo "- SSH_HOST: ${{ secrets.SSH_HOST }}"
          echo "- SSH_PORT: ${{ secrets.SSH_PORT }}"
          echo "- SSH_USER: ${{ secrets.SSH_USER }}"
          
          # Create .ssh directory
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Save private key
          echo "üîë Saving SSH private key..."
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          # Verify private key was saved
          if [ ! -f ~/.ssh/id_rsa ]; then
            echo "‚ùå Error: Failed to save private key"
            exit 1
          fi
          
          # Enhanced network diagnostics
          echo "üîç Running comprehensive network diagnostics..."
          echo "üîπ Local hostname: $(hostname)"
          echo "üîπ Local IP addresses: $(hostname -I 2>/dev/null || ip addr 2>/dev/null || echo 'Not available')"
          echo "üîπ Target host: ${{ secrets.SSH_HOST }}:${{ secrets.SSH_PORT }}"
          
          # Test basic ICMP connectivity
          echo "\nüîç Testing basic ICMP connectivity to ${{ secrets.SSH_HOST }}..."
          if ping -c 3 -W 2 ${{ secrets.SSH_HOST }} 2>&1; then
            echo "‚úÖ ICMP ping successful"
          else
            echo "‚ö†Ô∏è  ICMP ping failed - host might be blocking ICMP or is unreachable"
          fi
          
          # Test common SSH ports if the configured one fails
          echo "\nüîç Testing common SSH ports (this may take a moment)..."
          for port in ${{ secrets.SSH_PORT }} 22 2222 2022 222; do
            echo -n "üîπ Testing port $port: "
            if timeout 3 bash -c "echo > /dev/tcp/${{ secrets.SSH_HOST }}/$port" 2>/dev/null; then
              echo "‚úÖ OPEN - SSH might be running here!"
              echo "   Try using this port instead of the current one."
            else
              echo "‚ùå CLOSED or filtered"
            fi
          done
          
          # Check if any port is open
          echo "\nüîç Quick port scan (top 20 common ports)..."
          for port in 21 22 23 25 53 80 110 111 135 139 143 443 445 993 995 1723 3306 3389 5900 8080; do
            if timeout 1 bash -c "echo > /dev/tcp/${{ secrets.SSH_HOST }}/$port" 2>/dev/null; then
              echo "üî∏ Port $port: OPEN - Service might be running"
            fi
          done
          
          # Try different ssh-keyscan formats
          echo "üîç Trying different ssh-keyscan formats..."
          
          MAX_RETRIES=3
          RETRY_DELAY=5
          
          for ((i=1; i<=$MAX_RETRIES; i++)); do
            echo "\nüîç Attempt $i/$MAX_RETRIES - Testing SSH connection..."
            
            # Try different ssh-keyscan formats
            for format in "" "-t rsa" "-t ecdsa" "-t ed25519"; do
              echo "  üîπ Trying ssh-keyscan $format..."
              ssh-keyscan $format -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_HOST }} 2>> ssh-keyscan-errors.log | tee -a ~/.ssh/known_hosts
            done
            
            # Check if any keys were added
            if grep -q "${{ secrets.SSH_HOST }}" ~/.ssh/known_hosts 2>/dev/null; then
              echo "‚úÖ Successfully added host keys to known_hosts"
              break
            fi
            
            if [ $i -eq $MAX_RETRIES ]; then
              echo "\n‚ùå Failed to add host to known_hosts after $MAX_RETRIES attempts"
              echo "üîç ssh-keyscan errors:"
              cat ssh-keyscan-errors.log 2>/dev/null || echo "No error log found"
              echo "\nüîç Current known_hosts content:"
              cat ~/.ssh/known_hosts 2>/dev/null || echo "No known_hosts file found"
              echo "\n‚ö†Ô∏è  Please verify the following:"
              echo "1. The SSH server is running on port ${{ secrets.SSH_PORT }}"
              echo "2. The firewall allows incoming connections on port ${{ secrets.SSH_PORT }}"
              echo "3. The server is reachable from GitHub Actions runners"
              echo "4. The SSH server is configured to accept key-based authentication"
              exit 1
            fi
            
            echo "‚ö†Ô∏è  Attempt $i/$MAX_RETRIES failed, retrying in ${RETRY_DELAY}s..."
            sleep $RETRY_DELAY
          done
          
          # Test connection with retry logic
          MAX_RETRIES=3
          RETRY_DELAY=10
          
          for ((i=1; i<=$MAX_RETRIES; i++)); do
            echo "\nüîå Attempt $i/$MAX_RETRIES - Testing SSH connection to ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:${{ secrets.SSH_PORT }}"
            
            # SSH command with verbose debug output
            if ssh -v -v -v $SSH_OPTS -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "echo '‚úÖ SSH connection successful!'"; then
              echo "‚úÖ Successfully connected to ${{ secrets.SSH_HOST }}:${{ secrets.SSH_PORT }}"
              exit 0  # Exit with success
            else
              SSH_EXIT_CODE=$?
              echo "‚ö†Ô∏è  SSH connection failed with code: $SSH_EXIT_CODE"
              
              if [ $i -eq $MAX_RETRIES ]; then
                echo "‚ùå Failed to connect after $MAX_RETRIES attempts"
                
                # Additional debug information
                echo "\nüîç Debug information:"
                echo "- Current directory: $(pwd)"
                echo "- SSH directory contents:"
                ls -la ~/.ssh/
                echo "- Known hosts file:"
                cat ~/.ssh/known_hosts || true
                
                exit 1
              fi
              
              echo "‚è≥ Retrying in ${RETRY_DELAY}s... ($((MAX_RETRIES-i)) attempts remaining)"
              sleep $RETRY_DELAY
            fi
          done

      - name: Copy files to server
        run: |
          set -e
          echo "üì¶ Preparing files for deployment..."
          
          # Save Docker image to tar file
          IMAGE_TAR="${{ env.IMAGE_NAME }}.tar"
          echo "üíæ Saving Docker image to $IMAGE_TAR..."
          docker save -o $IMAGE_TAR ${{ env.IMAGE_NAME }}:${{ steps.set_tag.outputs.tag }}
          
          # Copy files to server
          echo "üì§ Transferring files to server on port ${{ secrets.SSH_PORT }}..."
          scp $SSH_OPTS -P ${{ secrets.SSH_PORT }} \
            $IMAGE_TAR \
            docker-compose.yml \
            docker-swarm.yml \
            ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:~/ || {
              echo "‚ùå Failed to copy files to server"
              exit 1
            }
          
          echo "‚úÖ Files successfully transferred to server"

      - name: Deploy with Docker Swarm
        env:
          DEPLOY_TAG: ${{ steps.set_tag.outputs.tag }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
        run: |
          echo "üöÄ Starting deployment process on port ${{ secrets.SSH_PORT }}..."
          
          ssh $SSH_OPTS -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} << 'ENDSSH'
            set -e
            
            echo "üîç Deployment details:"
            echo "  - Image: $IMAGE_NAME"
            echo "  - Tag: $DEPLOY_TAG"
            echo "  - Timestamp: $(date)"
            
            # Load the Docker image
            echo "\nüì• Loading Docker image..."
            docker load -i ~/$IMAGE_NAME.tar || {
              echo "‚ùå Failed to load Docker image"
              exit 1
            }
            
            # Set environment variable for docker-compose and docker-swarm
            export IMAGE_TAG=$DEPLOY_TAG
            
            # Deploy with docker-compose (for single node testing)
            echo "\nüê≥ Deploying with docker-compose..."
            docker-compose down 2>/dev/null || true
            docker-compose up -d
            
            # Show running containers
            echo "\nüì¶ Running containers:"
            docker ps --format "table {{.ID}}\t{{.Names}}\t{{.Status}}\t{{.Ports}}"
            
            # Initialize Docker Swarm if not already initialized
            if ! docker node ls &>/dev/null; then
              echo "\nüêù Initializing Docker Swarm..."
              docker swarm init --advertise-addr 127.0.0.1 || \
                echo "‚ö†Ô∏è  Swarm already initialized or error occurred"
            fi
            
            # Deploy with Docker Swarm (5 replicas)
            echo "\nüöÄ Deploying with Docker Swarm (5 replicas)..."
            docker stack deploy -c docker-swarm.yml academia-novit
            
            # Wait for services to start
            echo "\n‚è≥ Waiting for services to stabilize..."
            sleep 15
            
            # Show services and their status
            echo "\nüìä Docker services status:"
            docker service ls
            
            # Show service details
            echo "\nüîç Service details:"
            docker service ps academia-novit_web --no-trunc || true
            
            # Show network information
            echo "\nüåê Network information:"
            docker network ls
            
            # Show service logs
            echo "\nüìù Service logs (last 10 lines):"
            docker service logs --tail 10 academia-novit_web 2>&1 || true
            
            # Verify service health
            echo "\n‚úÖ Deployment completed successfully!"
            echo "üîÑ Services are being deployed with 5 replicas"
            echo "üîó API should be available shortly at: http://localhost:80"
          ENDSSH
