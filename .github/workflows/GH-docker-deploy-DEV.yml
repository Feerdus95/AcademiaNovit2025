name: Deploy to DEV with Docker Swarm

on:
  push:
    branches: [development]
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Docker image tag to deploy"
        required: true
        default: "development"

# Environment variables
defaults:
  run:
    shell: bash

env:
  IMAGE_NAME: academianovit
  DEFAULT_TAG: development
  SSH_OPTS: "-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=30"

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set image tag
        id: set_tag
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
          else
            echo "tag=${{ env.DEFAULT_TAG }}" >> $GITHUB_OUTPUT
          fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          install: true

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          tags: ${{ env.IMAGE_NAME }}:${{ steps.set_tag.outputs.tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Setup SSH connection
        run: |
          set -ex  # Enable debug mode and exit on error

          echo "üöÄ Setting up SSH connection..."
          echo "üîç Debug Info:"
          echo "- SSH_HOST: ${{ secrets.SSH_HOST }}"
          echo "- SSH_PORT: ${{ secrets.SSH_PORT }}"
          echo "- SSH_USER: ${{ secrets.SSH_USER }}"

          # Create .ssh directory
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh

          # Save private key
          echo "üîë Saving SSH private key..."
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

          # Verify private key was saved
          if [ ! -f ~/.ssh/id_rsa ]; then
            echo "‚ùå Error: Failed to save private key"
            exit 1
          fi

          # Network diagnostics summary
          echo "üîç Network diagnostics:"
          echo "üîπ Local hostname: $(hostname)"
          echo "üîπ Local IP addresses: $(hostname -I 2>/dev/null || ip addr 2>/dev/null || echo 'Not available')"
          echo "üîπ Target host: ${{ secrets.SSH_HOST }}:${{ secrets.SSH_PORT }}"

          # Verify SSH connectivity on the specified port
          echo "\nüîç Verifying SSH access on port ${{ secrets.SSH_PORT }}..."
          if timeout 5 bash -c "echo > /dev/tcp/${{ secrets.SSH_HOST }}/${{ secrets.SSH_PORT }}" 2>/dev/null; then
            echo "‚úÖ Port ${{ secrets.SSH_PORT }} is open and accessible"
          else
            echo "‚ùå Port ${{ secrets.SSH_PORT }} is not accessible. Please check:"
            echo "1. The SSH server is running on the target host"
            echo "2. The firewall allows incoming connections on port ${{ secrets.SSH_PORT }}"
            echo "3. The server is reachable from GitHub Actions runners"
            exit 1
          fi

          # Add server to known_hosts
          echo "üîç Adding SSH host key to known_hosts on port ${{ secrets.SSH_PORT }}..."
          ssh-keyscan -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_HOST }} 2>> ssh-keyscan-errors.log | tee -a ~/.ssh/known_hosts

          MAX_RETRIES=3
          RETRY_DELAY=5
            
            # Check if any keys were added
            if grep -q "${{ secrets.SSH_HOST }}" ~/.ssh/known_hosts 2>/dev/null; then
              echo "‚úÖ Successfully added host keys to known_hosts"
              break
            fi
            
            if [ $i -eq $MAX_RETRIES ]; then
              echo "\n‚ùå Failed to add host to known_hosts after $MAX_RETRIES attempts"
              echo "üîç ssh-keyscan errors:"
              cat ssh-keyscan-errors.log 2>/dev/null || echo "No error log found"
              echo "\nüîç Current known_hosts content:"
              cat ~/.ssh/known_hosts 2>/dev/null || echo "No known_hosts file found"
              echo "\n‚ö†Ô∏è  Please verify the following:"
              echo "1. The SSH server is running on port ${{ secrets.SSH_PORT }}"
              echo "2. The firewall allows incoming connections on port ${{ secrets.SSH_PORT }}"
              echo "3. The server is reachable from GitHub Actions runners"
              echo "4. The SSH server is configured to accept key-based authentication"
              exit 1
            fi
            
            echo "‚ö†Ô∏è  Attempt $i/$MAX_RETRIES failed, retrying in ${RETRY_DELAY}s..."
            sleep $RETRY_DELAY
          done

          # Test connection with retry logic
          MAX_RETRIES=3
          RETRY_DELAY=10

          for ((i=1; i<=$MAX_RETRIES; i++)); do
            echo "\nüîå Attempt $i/$MAX_RETRIES - Testing SSH connection to ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:${{ secrets.SSH_PORT }}"
            
            # SSH command with verbose debug output
            if ssh -v -v -v $SSH_OPTS -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "echo '‚úÖ SSH connection successful!'"; then
              echo "‚úÖ Successfully connected to ${{ secrets.SSH_HOST }}:${{ secrets.SSH_PORT }}"
              exit 0  # Exit with success
            else
              SSH_EXIT_CODE=$?
              echo "‚ö†Ô∏è  SSH connection failed with code: $SSH_EXIT_CODE"
              
              if [ $i -eq $MAX_RETRIES ]; then
                echo "‚ùå Failed to connect after $MAX_RETRIES attempts"
                
                # Additional debug information
                echo "\nüîç Debug information:"
                echo "- Current directory: $(pwd)"
                echo "- SSH directory contents:"
                ls -la ~/.ssh/
                echo "- Known hosts file:"
                cat ~/.ssh/known_hosts || true
                
                exit 1
              fi
              
              echo "‚è≥ Retrying in ${RETRY_DELAY}s... ($((MAX_RETRIES-i)) attempts remaining)"
              sleep $RETRY_DELAY
            fi
          done

      - name: Copy files to server
        run: |
          set -e
          echo "üì¶ Preparing files for deployment..."

          # Save Docker image to tar file
          IMAGE_TAR="${{ env.IMAGE_NAME }}.tar"
          echo "üíæ Saving Docker image to $IMAGE_TAR..."
          docker save -o $IMAGE_TAR ${{ env.IMAGE_NAME }}:${{ steps.set_tag.outputs.tag }}

          # Copy files to server
          echo "üì§ Transferring files to server on port ${{ secrets.SSH_PORT }}..."
          scp $SSH_OPTS -P ${{ secrets.SSH_PORT }} \
            $IMAGE_TAR \
            docker-compose.yml \
            docker-swarm.yml \
            ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:~/ || {
              echo "‚ùå Failed to copy files to server"
              exit 1
            }

          echo "‚úÖ Files successfully transferred to server"

      - name: Deploy with Docker Swarm
        env:
          DEPLOY_TAG: ${{ steps.set_tag.outputs.tag }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
        run: |
          echo "üöÄ Starting deployment process on port ${{ secrets.SSH_PORT }}..."

          ssh $SSH_OPTS -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} << 'ENDSSH'
            set -e
            
            echo "üîç Deployment details:"
            echo "  - Image: $IMAGE_NAME"
            echo "  - Tag: $DEPLOY_TAG"
            echo "  - Timestamp: $(date)"
            
            # Load the Docker image
            echo "\nüì• Loading Docker image..."
            docker load -i ~/$IMAGE_NAME.tar || {
              echo "‚ùå Failed to load Docker image"
              exit 1
            }
            
            # Set environment variable for docker-compose and docker-swarm
            export IMAGE_TAG=$DEPLOY_TAG
            
            # Deploy with docker-compose (for single node testing)
            echo "\nüê≥ Deploying with docker-compose..."
            docker-compose down 2>/dev/null || true
            docker-compose up -d
            
            # Show running containers
            echo "\nüì¶ Running containers:"
            docker ps --format "table {{.ID}}\t{{.Names}}\t{{.Status}}\t{{.Ports}}"
            
            # Initialize Docker Swarm if not already initialized
            if ! docker node ls &>/dev/null; then
              echo "\nüêù Initializing Docker Swarm..."
              docker swarm init --advertise-addr 127.0.0.1 || \
                echo "‚ö†Ô∏è  Swarm already initialized or error occurred"
            fi
            
            # Deploy with Docker Swarm (5 replicas)
            echo "\nüöÄ Deploying with Docker Swarm (5 replicas)..."
            docker stack deploy -c docker-swarm.yml academia-novit
            
            # Wait for services to start
            echo "\n‚è≥ Waiting for services to stabilize..."
            sleep 15
            
            # Show services and their status
            echo "\nüìä Docker services status:"
            docker service ls
            
            # Show service details
            echo "\nüîç Service details:"
            docker service ps academia-novit_web --no-trunc || true
            
            # Show network information
            echo "\nüåê Network information:"
            docker network ls
            
            # Show service logs
            echo "\nüìù Service logs (last 10 lines):"
            docker service logs --tail 10 academia-novit_web 2>&1 || true
            
            # Verify service health
            echo "\n‚úÖ Deployment completed successfully!"
            echo "üîÑ Services are being deployed with 5 replicas"
            echo "üîó API should be available shortly at: http://localhost:80"
          ENDSSH
